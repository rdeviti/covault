# Copyright (c) 2025 Roberta De Viti <rdeviti-at-mpi-sws.org> 
# Author: Roberta De Viti 
# SPDX-License-Identifier: MIT
#
# Parse logs generated by ag2pc and calculate mean and standard deviation of times.

import re
import numpy as np
import pandas as pd
import sys

"""Parse logs generated by ag2pc and calculate mean and standard deviation of times."""
def parse_times(data):
    lines = data.strip().splitlines()
    
    # Categories to parse
    CATEGORIES = ["one time", "ABIT", "check", "permute", "inde", "dep", "online"]

    # Regex patterns for different lines
    ignore_pattern = re.compile(r"\d+\s+\d+\s+\d+\s+\d+")
    PATTERNS = {
        "one time": re.compile(r"one time:\s+\d+\s+([\de\+\-\.]+)"),
        "ABIT": re.compile(r"ABIT\s+([\de\+\-\.]+)"),
        "check": re.compile(r"check\s+([\de\+\-\.]+)"),
        "permute": re.compile(r"permute\s+([\de\+\-\.]+)"),
        "inde": re.compile(r"inde:\s+\d+\s+([\de\+\-\.]+)"),
        "dep": re.compile(r"dep:\s+\d+\s+([\de\+\-\.]+)"),
        "online": re.compile(r"online:\s+\d+\s+([\de\+\-\.]+)")
    }

    # Initialize a dictionary to store times for each category
    times = {category: [] for category in CATEGORIES}

    # Iterate through each line and match patterns, ignoring the irrelevant lines
    for line in lines:
        if ignore_pattern.match(line):
            continue
        for category, pattern in PATTERNS.items():
            if match := pattern.search(line):
                times[category].append(float(match.group(1)))

    # Convert microseconds to seconds and calculate statistics
    stats = {category: (np.mean(times[category])/1e6, np.std(times[category])/1e6)
             for category in times if times[category]}

    return stats

"""Main function to read input file, parse times and calculate statistics."""
def main(input_file, verbose=True):
    # Read input file
    try:
        with open(input_file, 'r') as f:
            data = f.read()
    except FileNotFoundError:
        print(f"Error: File {input_file} not found.")
        sys.exit(1)
    except IOError as e:
        print(f"Error reading file {input_file}: {e}")
        sys.exit(1)

    # Calculate statistics
    stats = parse_times(data)

    if verbose:
        # Print the output for each set
        print(f"Mean (s),Std Dev (s)")
        for category, values in stats.items():
            print(f"{category},{values[0]},{values[1]}")

    # Calculate the sum of means and std devs for specified categories across all output sets
    # (ignores the times of sub-computations like ABIT, check, permute)
    categories_to_sum = ["one time", "inde", "dep", "online"]
    total_mean = sum(stats[category][0] for category in categories_to_sum if category in stats)
    total_variance = sum(stats[category][1]**2 for category in categories_to_sum if category in stats)
    total_stddev = np.sqrt(total_variance)

    if verbose:    
        # Print the total (mean, std) in CSV format
        print("Total: 'one time', 'inde', 'dep', 'online'")
        print(f"Mean(s),StdDev(s)")
        print(f"{total_mean},{total_stddev}")

    # Dump to file
    output_file = input_file.rsplit('.txt', 1)[0] + '_time.csv'
    with open(output_file, 'w') as fd:
        fd.write(f"{total_mean},{total_stddev}\n")

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: python ag2pc_parser.py <input_file> [--verbose]")
        sys.exit(1)

    input_file = sys.argv[1]
    verbose = "--verbose" in sys.argv
    main(input_file, verbose=verbose)
